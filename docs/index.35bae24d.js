class t{//FIXME: добавить возможность настраивать вещи налету
constructor({debug:i}){if(t._instance)return t._instance;t._instance=this,this.particleRadius=20,this.gravity=9.8,this.precalc={radiusFactor:this.particleRadius/(this.particleRadius+this.particleRadius),circleAngle:2*Math.PI},this.timeSpeedCoefficient=30,this.targetFrameTime=1e3/60,this.friction=.9,this.debug=!!i}}class i{static new(t,i){return{x:t??0,y:i??0}}static multiplyScalar({x:t,y:i},e){return{x:t*e,y:i*e}}static add(t,i){return{x:t.x+i.x,y:t.y+i.y}}static subtract(t,i){return{x:t.x-i.x,y:t.y-i.y}}static dot(t,i){return t.x*i.x+t.y*i.y}static magnitude({x:t,y:i}){return Math.sqrt(t*t+i*i)}static normalize({x:t,y:e}){let a=i.magnitude({x:t,y:e});return{x:t/a,y:e/a}}static collisionNormal(t,e){return i.normalize(i.subtract(t,e))}static reflectFromPoint(t,e,a){let s=i.collisionNormal(t,e);return i.subtract(a,i.multiplyScalar(s,2*i.dot(a,s)))}static reflectFromNormal(t,e){// v' = v - 2 * (v ∙ n/n ∙ n) * n
return i.subtract(t,i.multiplyScalar(e,2*i.dot(t,e)/i.dot(e,e)))}}class e{constructor(){if(this.addParticle=(t,e,a,s,r)=>{this.particles.push({position:i.new(t,e),velocity:i.new(a,s),relativeVelocity:i.new(0,0),color:r})},//TODO: add possibility to create diagonal obstacles
this.addObstacle=(t,i,e,a)=>{this.obstacles.push({data:[t,i,e,a]})},e._instance)return e._instance;e._instance=this,this.particles=[],this.obstacles=[]}}class a{static prepareFrame(t,e,s){for(let r=0;r<t.particles.length;r++){a._resolveCollisions(r,t,e);let{position:l,velocity:c}=t.particles[r],n=i.new(c.x,c.y+e.gravity),o=a.getRelativeVelocity(n,s),h=i.new(l.x+o.x,l.y+o.y);t.particles[r]={...t.particles[r],velocity:n,relativeVelocity:o,position:h}}}static _particleIntersectsObstacle(t,e,a){let{data:[s,r,l,c]}=t,n=l/2,o=c/2,h=i.new(Math.abs(e.x-Math.abs(s+n)),Math.abs(e.y-Math.abs(r+o)));if(h.x>n+a.particleRadius||h.y>o+a.particleRadius)return!1;if(h.x<=n||h.y<=o)return!0;let d=(h.x-n)*2+(h.y-o)*2;return d<=2*a.particleRadius}//FIXME: Separate collision detection from collision response to allow for event listeners
static _resolveObstacleCollisions(t,e,s){for(let r=0;r<e.obstacles.length;r++){// eslint-disable-next-line prefer-const
let{position:l,velocity:c}=e.particles[t];if(a._particleIntersectsObstacle(e.obstacles[r],l,s)){let{data:[n,o,h,d]}=e.obstacles[r],p=n+h,u=o+d,y=i.new(l.x<n?n:l.x>p?p:l.x,l.y<o?o:l.y>u?u:l.y),m=Math.sqrt(Math.pow(y.x-l.x,2)+Math.pow(y.y-l.y,2)),x=s.particleRadius-m;if(x>0){//if particle intersects obstacle, move particle away
let t=(l.x-y.x)/m,e=(l.y-y.y)/m;l=i.new(l.x+t*x,l.y+e*x)}e.particles[t]={...e.particles[t],position:l,velocity:a.applyFriction(i.reflectFromPoint(y,l,c),s)}}}}static _resolveParticleCollisions(t,e,s){let{position:r,velocity:l}=e.particles[t];for(let c=0;c<e.particles.length;c++){if(c<=t)continue;let{position:n,velocity:o}=e.particles[c],h=n.x-r.x,d=n.y-r.y,p=Math.sqrt(h*h+d*d);if(p<2*s.particleRadius){//check if particles intersect
let u=s.particleRadius+s.particleRadius-p;//if they intersect, move them apart evenly
if(u>0){let t=h/p,e=d/p;r=i.new(r.x-t*u/2,r.y-e*u/2),n=i.new(n.x+t*u/2,n.y+e*u/2)}let y=i.add(i.multiplyScalar(r,s.precalc.radiusFactor),i.multiplyScalar(n,s.precalc.radiusFactor));e.particles[t]={...e.particles[t],position:r,velocity:a.applyFriction(i.reflectFromPoint(y,n,l),s)},e.particles[c]={...e.particles[c],position:n,velocity:a.applyFriction(i.reflectFromPoint(y,r,o),s)}}}}static _resolveCollisions(t,i,e){a._resolveObstacleCollisions(t,i,e),a._resolveParticleCollisions(t,i,e)}static applyFriction(t,e){return i.multiplyScalar(t,e.friction)}static getRelativeVelocity(t,i){//FIXME: изменение дельта тайма меняет результат симуляции, надо решать с интерполяцией что-то
return{x:t.x*i.deltaTime,y:t.y*i.deltaTime}}}class s{static drawFrame(t,i,e){t.context.clearRect(0,0,t.canvas.width,t.canvas.height),e.particles.forEach(({position:e,color:a})=>{t.context.beginPath(),t.context.fillStyle=a,t.context.arc(e.x,e.y,i.particleRadius,0,i.precalc.circleAngle),t.context.fill()}),this._drawObstacles(t,e.obstacles)}static _drawObstacles(t,i){i.forEach(({data:i})=>{t.context.fillRect(...i)})}}class r{constructor(t,i){if(r._instance)return r._instance;r._instance=this,this.canvas=document.getElementById("canvas"),this.context=this.canvas.getContext("2d"),this.dpr=window.devicePixelRatio||1,this.rawDeltaTime=performance.now(),this.lastFrameTime=this.rawDeltaTime,this.isPaused=!1,this.options=t,this.entityManager=i,this.update=this.update.bind(this),this.onPause=this.onPause.bind(this)}init(){this.canvas.width=document.body.clientWidth*this.dpr,this.canvas.height=document.body.clientHeight*this.dpr,this.options.debug?window.addEventListener("click",()=>{this.rawDeltaTime=1,this.lastFrameTime=1,a.prepareFrame(this.entityManager,this.options,this),s.drawFrame(this,this.options,this.entityManager)}):(window.addEventListener("click",this.onPause),window.requestAnimationFrame(this.update))}update(t){this.rawDeltaTime=(t-this.lastFrameTime)/200,this.lastFrameTime=t,window.requestAnimationFrame(this.update),this.isPaused||(a.prepareFrame(this.entityManager,this.options,this),s.drawFrame(this,this.options,this.entityManager))}onPause(){this.isPaused=!this.isPaused}get deltaTime(){return this.rawDeltaTime}}const l=["red","green","blue","orange","pink"],c=new t({debug:!1}),n=new e;for(let t=0;t<=9;t++){let i=45*(t+1),e=60*(t+1);n.addParticle(i,e,t,0,l[Math.floor(5*Math.random())])}n.addObstacle(0,800,510,20),n.addObstacle(0,0,20,800),n.addObstacle(490,0,20,800),n.addObstacle(0,0,500,20);const o=new r(c,n);o.init();//# sourceMappingURL=index.35bae24d.js.map

//# sourceMappingURL=index.35bae24d.js.map
