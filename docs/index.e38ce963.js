class t{//FIXME: добавить возможность настраивать вещи налету
constructor({debug:i}){if(t._instance)return t._instance;t._instance=this,this.gravity=9.8,this.precalc={circleAngle:2*Math.PI},this.timeSpeedCoefficient=1,this.physicsIterations=8,this.physicsGridResolution=40,this.friction=.9,this.debug=!!i}}class i{static new(t,i){return{x:t??0,y:i??0}}static multiplyScalar({x:t,y:i},e){return{x:t*e,y:i*e}}static add(t,i){return{x:t.x+i.x,y:t.y+i.y}}static subtract(t,i){return{x:t.x-i.x,y:t.y-i.y}}static dot(t,i){return t.x*i.x+t.y*i.y}static magnitude({x:t,y:i}){return Math.sqrt(t*t+i*i)}static normalize({x:t,y:e}){let s=i.magnitude({x:t,y:e});return{x:t/s,y:e/s}}static collisionNormal(t,e){return i.normalize(i.subtract(t,e))}static reflectFromPoint(t,e,s){let a=i.collisionNormal(t,e);return i.subtract(s,i.multiplyScalar(a,2*i.dot(s,a)))}static reflectFromNormal(t,e){// v' = v - 2 * (v ∙ n/n ∙ n) * n
return i.subtract(t,i.multiplyScalar(e,2*i.dot(t,e)/i.dot(e,e)))}}class e{constructor(){if(this.addParticle=t=>{this.particles.push({id:this.particles.length,mass:t.mass??1,radius:t.radius??5,color:t.color??"blue",position:t.position??i.new(0,0),velocity:t.velocity??i.new(0,0),relativeVelocity:i.new(0,0)})},//TODO: add possibility to create diagonal obstacles
this.addObstacle=(t,i,e,s)=>{this.obstacles.push({data:[t,i,e,s]})},e._instance)return e._instance;e._instance=this,this.particles=[],this.obstacles=[]}}class s{static clamp(t,i,e){return Math.min(Math.max(t,i),e)}static createUniformGridOfSize(t){let i=[];for(let e=0;e<t;e++){i[e]=[];for(let s=0;s<t;s++)i[e][s]=[]}return i}}class a{static prepareFrame(t,e,l){let c=e.physicsIterations;/**
         * FIXME: нужно переделать колижен респонсы чтобы они затрагивали только текущий интервал, иначе нельзя будет запараллелить вычисления
         * Сейчас симуляция стабильно работает при радиусе партиклов >5 на моей машине, хотелось бы поменьше.
         * Нужна оптимизация + увеличение итераций физики
         */for(let o=0;o<c;o++){//UPD: .fill fills array with references to provided value :(
let o=s.createUniformGridOfSize(e.physicsGridResolution);//разбиение на клетки работает, насколько я могу судить.
//вроде как единственная проблема с текущим алгоритмом - это размер партиклов, если он больше клетки, то смэрть
for(let i=0;i<t.particles.length;i++){let{position:a,id:c,radius:r}=t.particles[i],n=s.clamp(Math.floor((a.x-r)/l.gridCellWidth),0,e.physicsGridResolution-1),h=s.clamp(Math.floor((a.x+r)/l.gridCellWidth),0,e.physicsGridResolution-1),d=s.clamp(Math.floor((a.y-r)/l.gridCellHeight),0,e.physicsGridResolution-1),p=s.clamp(Math.floor((a.y+r)/l.gridCellHeight),0,e.physicsGridResolution-1);o[n][d].push(c),n!==h&&o[h][d].push(c),p!==d&&(o[n][p].push(c),n!==h&&o[h][p].push(c))}for(let i=0;i<t.particles.length;i++)a._resolveObstacleCollisions(i,t,e);a._resolveParticleCollisions(t,e,o);for(let s=0;s<t.particles.length;s++){let{position:o,velocity:r}=t.particles[s],n=i.new(r.x,r.y+e.gravity),h=a.getRelativeVelocity(n,l,c),d=i.new(o.x+h.x,o.y+h.y);t.particles[s]={...t.particles[s],velocity:n,relativeVelocity:h,position:d}}}}static _particleIntersectsObstacle(t,e,s){let{data:[a,l,c,o]}=t,r=c/2,n=o/2,h=i.new(Math.abs(e.x-Math.abs(a+r)),Math.abs(e.y-Math.abs(l+n)));if(h.x>r+s||h.y>n+s)return!1;if(h.x<=r||h.y<=n)return!0;let d=(h.x-r)*2+(h.y-n)*2;return d<=2*s}//FIXME: Separate collision detection from collision response to allow for event listeners
static _resolveObstacleCollisions(t,e,s){for(let l=0;l<e.obstacles.length;l++){// eslint-disable-next-line prefer-const
let{position:c,velocity:o,radius:r}=e.particles[t];if(a._particleIntersectsObstacle(e.obstacles[l],c,r)){let{data:[n,h,d,p]}=e.obstacles[l],u=n+d,y=h+p,x=i.new(c.x<n?n:c.x>u?u:c.x,c.y<h?h:c.y>y?y:c.y),m=Math.sqrt(Math.pow(x.x-c.x,2)+Math.pow(x.y-c.y,2)),g=r-m;if(g>0){//if particle intersects obstacle, move particle away
let t=(c.x-x.x)/m,e=(c.y-x.y)/m;/**
                     * 0 / 0 could and should happen,
                     * when particle intersects obstacle exactly aligned with collision point,
                     * which gives NaN (for whatever reason),
                     * skip repositioning in this case
                     */if(isNaN(t)||isNaN(e))return;c=i.new(c.x+t*g,c.y+e*g)}e.particles[t]={...e.particles[t],position:c,velocity:a.applyFriction(i.reflectFromPoint(x,c,o),s)}}}}static _resolveParticleCollisions(t,e,s){s.forEach(s=>{s.forEach(s=>{s.forEach(l=>{// eslint-disable-next-line prefer-const
let{position:c,velocity:o,radius:r}=t.particles[l];s.forEach(s=>{if(s===l)return;// eslint-disable-next-line prefer-const
let{position:n,velocity:h,radius:d}=t.particles[s],p=n.x-c.x,u=n.y-c.y,y=Math.sqrt(p*p+u*u);if(y<2*r){//check if particles intersect
let x=r+d-y;//if they intersect, move them apart evenly
if(x>0){let t=p/y,e=u/y;c=i.new(c.x-t*x/2,c.y-e*x/2),n=i.new(n.x+t*x/2,n.y+e*x/2)}let m=i.add(i.multiplyScalar(c,r/(r+r)),i.multiplyScalar(n,d/(d+d)));t.particles[l]={...t.particles[l],position:c,velocity:a.applyFriction(i.reflectFromPoint(m,n,o),e)},t.particles[s]={...t.particles[s],position:n,velocity:a.applyFriction(i.reflectFromPoint(m,c,h),e)}}})})})})}static applyFriction(t,e){return i.multiplyScalar(t,e.friction)}static getRelativeVelocity(t,i,e){return{x:t.x*i.deltaTime/e,y:t.y*i.deltaTime/e}}}class l{static drawFrame(t,i,e){t.context.clearRect(0,0,t.canvas.width,t.canvas.height),e.particles.forEach(({position:e,color:s,radius:a})=>{t.context.beginPath(),t.context.fillStyle=s,t.context.arc(e.x,e.y,a,0,i.precalc.circleAngle),t.context.fill()}),this._drawObstacles(t,e.obstacles),i.debug&&this._drawDebugInfo(t,e)}static _drawDebugInfo(t,i){t.context.fillStyle="black",t.context.fillText(String(i.particles.length),10,10);// TODO: для каждого партикла
// app.context.fillStyle = 'black'
// app.context.fillText(String(id), position.x, position.y)
let{gridCellWidth:e,gridCellHeight:s}=t;//FIXME: make grid resolution choosable
for(let i=0;i<=t.options.physicsGridResolution;i++)t.context.strokeStyle="lightgreen",t.context.beginPath(),t.context.moveTo((i+1)*e,0),t.context.lineTo((i+1)*e,t.canvas.clientHeight),t.context.stroke(),t.context.beginPath(),t.context.moveTo(0,(i+1)*s),t.context.lineTo(t.canvas.clientWidth,(i+1)*s),t.context.stroke(),t.context.fillText(`${i}, ${i}`,i*e,i*s)}static _drawObstacles(t,i){t.context.fillStyle="grey",i.forEach(({data:i})=>{t.context.fillRect(...i)})}}class c{constructor(t,i){if(c._instance)return c._instance;c._instance=this,this.canvas=document.getElementById("canvas"),this.context=this.canvas.getContext("2d"),this.dpr=window.devicePixelRatio||1,this.rawDeltaTime=performance.now(),this.lastFrameTime=this.rawDeltaTime,this.isPaused=!1,this.options=t,this.entityManager=i,this.gridCellWidth=this.canvas.clientWidth/this.options.physicsGridResolution,this.gridCellHeight=this.canvas.clientHeight/this.options.physicsGridResolution,//FIXME: шину событий надо сделать
this.onUpdate=null,this.update=this.update.bind(this),this.onPause=this.onPause.bind(this)}init(){this.canvas.width=document.body.clientWidth*this.dpr,this.canvas.height=document.body.clientHeight*this.dpr,window.addEventListener("click",this.onPause),window.requestAnimationFrame(this.update)}update(t){this.rawDeltaTime=1/60*this.options.timeSpeedCoefficient,this.lastFrameTime=t,window.requestAnimationFrame(this.update),this.isPaused||(this.onUpdate&&this.onUpdate(t),a.prepareFrame(this.entityManager,this.options,this),l.drawFrame(this,this.options,this.entityManager))}onPause(){this.isPaused=!this.isPaused}get deltaTime(){return this.rawDeltaTime}}const o=new t({debug:!0}),r=new e,n=new c(o,r);r.addObstacle(0,n.canvas.clientHeight-20,n.canvas.clientWidth,20),r.addObstacle(0,0,20,n.canvas.clientHeight),r.addObstacle(n.canvas.clientWidth-20,0,20,n.canvas.clientHeight),r.addObstacle(0,0,n.canvas.clientWidth,20),n.init();let h=0;n.onUpdate=t=>{!(t-h<80)&&(r.particles.length>=2e3||(h=t,r.addParticle({position:i.new(30,30),velocity:i.new(5,0),color:"green",mass:1,radius:2}),r.addParticle({position:i.new(60,30),velocity:i.new(5,0),color:"red",mass:1,radius:2}),r.addParticle({position:i.new(90,30),velocity:i.new(5,0),color:"blue",mass:1,radius:2}),r.addParticle({position:i.new(120,30),velocity:i.new(5,0),color:"pink",mass:1,radius:2}),r.addParticle({position:i.new(150,30),velocity:i.new(5,0),color:"brown",mass:1,radius:2})))};//# sourceMappingURL=index.e38ce963.js.map

//# sourceMappingURL=index.e38ce963.js.map
