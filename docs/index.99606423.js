class t{//FIXME: добавить возможность настраивать вещи налету
constructor({debug:e}){if(t._instance)return t._instance;t._instance=this,this.gravity=9.8,this.precalc={circleAngle:2*Math.PI},this.timeSpeedCoefficient=1,this.physicsIterations=8,this.friction=.9,this.debug=!!e}}class e{static new(t,e){return{x:t??0,y:e??0}}static multiplyScalar({x:t,y:e},i){return{x:t*i,y:e*i}}static add(t,e){return{x:t.x+e.x,y:t.y+e.y}}static subtract(t,e){return{x:t.x-e.x,y:t.y-e.y}}static dot(t,e){return t.x*e.x+t.y*e.y}static magnitude({x:t,y:e}){return Math.sqrt(t*t+e*e)}static normalize({x:t,y:i}){let s=e.magnitude({x:t,y:i});return{x:t/s,y:i/s}}static collisionNormal(t,i){return e.normalize(e.subtract(t,i))}static reflectFromPoint(t,i,s){let a=e.collisionNormal(t,i);return e.subtract(s,e.multiplyScalar(a,2*e.dot(s,a)))}static reflectFromNormal(t,i){// v' = v - 2 * (v ∙ n/n ∙ n) * n
return e.subtract(t,e.multiplyScalar(i,2*e.dot(t,i)/e.dot(i,i)))}}class i{constructor(){if(this.addParticle=t=>{this.particles.push({id:this.particles.length,mass:t.mass??1,radius:t.radius??5,color:t.color??"blue",position:t.position??e.new(0,0),velocity:t.velocity??e.new(0,0),relativeVelocity:e.new(0,0)})},//TODO: add possibility to create diagonal obstacles
this.addObstacle=(t,e,i,s)=>{this.obstacles.push({data:[t,e,i,s]})},i._instance)return i._instance;i._instance=this,this.particles=[],this.obstacles=[]}}class s{static prepareFrame(t,i,a){let l=i.physicsIterations;/**
         * FIXME: нужно переделать колижен респонсы чтобы они затрагивали только текущий интервал, иначе нельзя будет запараллелить вычисления
         * Сейчас симуляция стабильно работает при радиусе партиклов >5 на моей машине, хотелось бы поменьше.
         * Нужна оптимизация + увеличение итераций физики
         */for(let r=0;r<l;r++){//FIXME: figure out why Array constructor doesn`t work
let r=[[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]],[[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]]];//разбиение на клетки работает, насколько я могу судить.
//вроде как единственная проблема с текущим алгоритмом - это размер партиклов, если он больше клетки, то смэрть
for(let e=0;e<t.particles.length;e++){let{position:i,id:s,radius:l}=t.particles[e],c=Math.floor((i.x-l)/a.gridWidth),o=Math.floor((i.x+l)/a.gridWidth),n=Math.floor((i.y-l)/a.gridHeight),h=Math.floor((i.y+l)/a.gridHeight);r[c][n].push(s),c!==o&&r[o][n].push(s),h!==n&&(r[c][h].push(s),c!==o&&r[o][h].push(s))}for(let e=0;e<t.particles.length;e++)s._resolveObstacleCollisions(e,t,i);s._resolveParticleCollisions(t,i,r);for(let r=0;r<t.particles.length;r++){let{position:c,velocity:o}=t.particles[r],n=e.new(o.x,o.y+i.gravity),h=s.getRelativeVelocity(n,a,l),d=e.new(c.x+h.x,c.y+h.y);t.particles[r]={...t.particles[r],velocity:n,relativeVelocity:h,position:d}}}}static _particleIntersectsObstacle(t,i,s){let{data:[a,l,r,c]}=t,o=r/2,n=c/2,h=e.new(Math.abs(i.x-Math.abs(a+o)),Math.abs(i.y-Math.abs(l+n)));if(h.x>o+s||h.y>n+s)return!1;if(h.x<=o||h.y<=n)return!0;let d=(h.x-o)*2+(h.y-n)*2;return d<=2*s}//FIXME: Separate collision detection from collision response to allow for event listeners
static _resolveObstacleCollisions(t,i,a){for(let l=0;l<i.obstacles.length;l++){// eslint-disable-next-line prefer-const
let{position:r,velocity:c,radius:o}=i.particles[t];if(s._particleIntersectsObstacle(i.obstacles[l],r,o)){let{data:[n,h,d,p]}=i.obstacles[l],y=n+d,u=h+p,x=e.new(r.x<n?n:r.x>y?y:r.x,r.y<h?h:r.y>u?u:r.y),m=Math.sqrt(Math.pow(x.x-r.x,2)+Math.pow(x.y-r.y,2)),g=o-m;if(g>0){//if particle intersects obstacle, move particle away
let t=(r.x-x.x)/m,i=(r.y-x.y)/m;r=e.new(r.x+t*g,r.y+i*g)}i.particles[t]={...i.particles[t],position:r,velocity:s.applyFriction(e.reflectFromPoint(x,r,c),a)}}}}static _resolveParticleCollisions(t,i,a){a.forEach(a=>{a.forEach(a=>{a.forEach(l=>{// eslint-disable-next-line prefer-const
let{position:r,velocity:c,radius:o}=t.particles[l];a.forEach(a=>{if(a===l)return;// eslint-disable-next-line prefer-const
let{position:n,velocity:h,radius:d}=t.particles[a],p=n.x-r.x,y=n.y-r.y,u=Math.sqrt(p*p+y*y);if(u<2*o){//check if particles intersect
let x=o+d-u;//if they intersect, move them apart evenly
if(x>0){let t=p/u,i=y/u;r=e.new(r.x-t*x/2,r.y-i*x/2),n=e.new(n.x+t*x/2,n.y+i*x/2)}let m=e.add(e.multiplyScalar(r,o/(o+o)),e.multiplyScalar(n,d/(d+d)));t.particles[l]={...t.particles[l],position:r,velocity:s.applyFriction(e.reflectFromPoint(m,n,c),i)},t.particles[a]={...t.particles[a],position:n,velocity:s.applyFriction(e.reflectFromPoint(m,r,h),i)}}})})})})}static applyFriction(t,i){return e.multiplyScalar(t,i.friction)}static getRelativeVelocity(t,e,i){return{x:t.x*e.deltaTime/i,y:t.y*e.deltaTime/i}}}class a{static drawFrame(t,e,i){t.context.clearRect(0,0,t.canvas.width,t.canvas.height),i.particles.forEach(({position:i,color:s,radius:a})=>{t.context.beginPath(),t.context.fillStyle=s,t.context.arc(i.x,i.y,a,0,e.precalc.circleAngle),t.context.fill()}),this._drawObstacles(t,i.obstacles),e.debug&&this._drawDebugInfo(t,i)}static _drawDebugInfo(t,e){t.context.fillStyle="black",t.context.fillText(String(e.particles.length),10,10);// TODO: для каждого партикла
// app.context.fillStyle = 'black'
// app.context.fillText(String(id), position.x, position.y)
let{gridWidth:i,gridHeight:s}=t;//FIXME: make grid resolution choosable
for(let e=0;e<=20;e++)t.context.strokeStyle="lightgreen",t.context.beginPath(),t.context.moveTo((e+1)*i,0),t.context.lineTo((e+1)*i,t.canvas.clientHeight),t.context.stroke(),t.context.beginPath(),t.context.moveTo(0,(e+1)*s),t.context.lineTo(t.canvas.clientWidth,(e+1)*s),t.context.stroke(),t.context.fillText(`${e}, ${e}`,(e+.45)*i,(e+.5)*s)}static _drawObstacles(t,e){t.context.fillStyle="grey",e.forEach(({data:e})=>{t.context.fillRect(...e)})}}class l{constructor(t,e){if(l._instance)return l._instance;l._instance=this,this.canvas=document.getElementById("canvas"),this.context=this.canvas.getContext("2d"),this.dpr=window.devicePixelRatio||1,this.rawDeltaTime=performance.now(),this.lastFrameTime=this.rawDeltaTime,this.isPaused=!1,this.options=t,this.entityManager=e,//TODO: сделать настраиваемым
this.gridWidth=this.canvas.clientWidth/20,this.gridHeight=this.canvas.clientHeight/20,this.update=this.update.bind(this),this.onPause=this.onPause.bind(this)}init(){this.canvas.width=document.body.clientWidth*this.dpr,this.canvas.height=document.body.clientHeight*this.dpr,//TODO: integrate stepping
// if (this.options.debug) {
//     window.addEventListener('click', () => {
//         this.rawDeltaTime = 1
//         this.lastFrameTime = 1
//         Physics.prepareFrame(this.entityManager, this.options, this)
//         Renderer.drawFrame(this, this.options, this.entityManager)
//     })
// }
window.addEventListener("click",this.onPause),window.requestAnimationFrame(this.update)}update(t){this.rawDeltaTime=1/60*this.options.timeSpeedCoefficient,this.lastFrameTime=t,window.requestAnimationFrame(this.update),this.isPaused||(s.prepareFrame(this.entityManager,this.options,this),a.drawFrame(this,this.options,this.entityManager))}onPause(){this.isPaused=!this.isPaused}get deltaTime(){return this.rawDeltaTime}}const r=new t({debug:!1}),c=new i;c.addObstacle(0,800,510,20),c.addObstacle(0,0,20,800),c.addObstacle(490,0,20,800),c.addObstacle(0,0,500,20);const o=new l(r,c);o.init(),setInterval(()=>{c.particles.length>=2e3||(c.addParticle({position:e.new(30,30),velocity:e.new(5,0),color:"green",mass:1,radius:5}),c.addParticle({position:e.new(60,30),velocity:e.new(5,0),color:"red",mass:1,radius:5}),c.addParticle({position:e.new(90,30),velocity:e.new(5,0),color:"blue",mass:1,radius:5}),c.addParticle({position:e.new(120,30),velocity:e.new(5,0),color:"pink",mass:1,radius:5}),c.addParticle({position:e.new(150,30),velocity:e.new(5,0),color:"pink",mass:1,radius:5}))},150);//# sourceMappingURL=index.99606423.js.map

//# sourceMappingURL=index.99606423.js.map
