{"mappings":"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","sources":["<anon>","src/main.ts","src/utils/Options.ts","src/utils/EntityManager.ts","src/utils/Vector2.ts","src/utils/App.ts","src/utils/Physics.ts","src/utils/Renderer.ts"],"sourcesContent":["(function () {\nclass $bbaf2cf5fdf02c7e$export$c019608e5b5bb4cb {\n    //FIXME: добавить возможность настраивать вещи налету\n    constructor({ debug: debug }){\n        if ($bbaf2cf5fdf02c7e$export$c019608e5b5bb4cb._instance) return $bbaf2cf5fdf02c7e$export$c019608e5b5bb4cb._instance;\n        $bbaf2cf5fdf02c7e$export$c019608e5b5bb4cb._instance = this;\n        this.particleRadius = 20;\n        this.gravity = 9.8;\n        this.precalc = {\n            radiusFactor: this.particleRadius / (this.particleRadius + this.particleRadius),\n            circleAngle: 2 * Math.PI\n        };\n        this.timeSpeedCoefficient = 30;\n        this.targetFrameTime = 1000 / 60;\n        this.friction = 0.90;\n        this.debug = !!debug;\n    }\n}\n\n\nclass $056e076ec23198f1$export$ac4bca90992eed1 {\n    static new(x, y) {\n        return {\n            x: x ?? 0,\n            y: y ?? 0\n        };\n    }\n    static multiplyScalar({ x: x, y: y }, num) {\n        return {\n            x: x * num,\n            y: y * num\n        };\n    }\n    static add(v1, v2) {\n        return {\n            x: v1.x + v2.x,\n            y: v1.y + v2.y\n        };\n    }\n    static subtract(v1, v2) {\n        return {\n            x: v1.x - v2.x,\n            y: v1.y - v2.y\n        };\n    }\n    static dot(v1, v2) {\n        return v1.x * v2.x + v1.y * v2.y;\n    }\n    static magnitude({ x: x, y: y }) {\n        return Math.sqrt(x * x + y * y);\n    }\n    static normalize({ x: x, y: y }) {\n        const magnitude = $056e076ec23198f1$export$ac4bca90992eed1.magnitude({\n            x: x,\n            y: y\n        });\n        return {\n            x: x / magnitude,\n            y: y / magnitude\n        };\n    }\n    static collisionNormal(collisionPoint, position) {\n        return $056e076ec23198f1$export$ac4bca90992eed1.normalize($056e076ec23198f1$export$ac4bca90992eed1.subtract(collisionPoint, position));\n    }\n    static reflectFromPoint(collisionPoint, position, velocity) {\n        const normal = $056e076ec23198f1$export$ac4bca90992eed1.collisionNormal(collisionPoint, position);\n        return $056e076ec23198f1$export$ac4bca90992eed1.subtract(velocity, $056e076ec23198f1$export$ac4bca90992eed1.multiplyScalar(normal, 2 * $056e076ec23198f1$export$ac4bca90992eed1.dot(velocity, normal)));\n    }\n    static reflectFromNormal(vector, normal) {\n        // v' = v - 2 * (v ∙ n/n ∙ n) * n\n        return $056e076ec23198f1$export$ac4bca90992eed1.subtract(vector, $056e076ec23198f1$export$ac4bca90992eed1.multiplyScalar(normal, 2 * $056e076ec23198f1$export$ac4bca90992eed1.dot(vector, normal) / $056e076ec23198f1$export$ac4bca90992eed1.dot(normal, normal)));\n    }\n}\n\n\nclass $1a12250a5920d5f0$export$c7b7134fd828a5 {\n    constructor(){\n        this.addParticle = (x, y, xv, yv, color)=>{\n            this.particles.push({\n                position: (0, $056e076ec23198f1$export$ac4bca90992eed1).new(x, y),\n                velocity: (0, $056e076ec23198f1$export$ac4bca90992eed1).new(xv, yv),\n                relativeVelocity: (0, $056e076ec23198f1$export$ac4bca90992eed1).new(0, 0),\n                color: color\n            });\n        };\n        //TODO: add possibility to create diagonal obstacles\n        this.addObstacle = (x, y, w, h)=>{\n            this.obstacles.push({\n                data: [\n                    x,\n                    y,\n                    w,\n                    h\n                ]\n            });\n        };\n        if ($1a12250a5920d5f0$export$c7b7134fd828a5._instance) return $1a12250a5920d5f0$export$c7b7134fd828a5._instance;\n        $1a12250a5920d5f0$export$c7b7134fd828a5._instance = this;\n        this.particles = [];\n        this.obstacles = [];\n    }\n}\n\n\n\nclass $a92a30bff2b267c9$export$2f09efa5b67124a7 {\n    static prepareFrame(entityManager, options, app) {\n        for(let i = 0; i < entityManager.particles.length; i++){\n            $a92a30bff2b267c9$export$2f09efa5b67124a7._resolveCollisions(i, entityManager, options);\n            const { position: position, velocity: velocity } = entityManager.particles[i];\n            const newVelocity = (0, $056e076ec23198f1$export$ac4bca90992eed1).new(velocity.x, velocity.y + options.gravity);\n            const newRelativeVelocity = $a92a30bff2b267c9$export$2f09efa5b67124a7.getRelativeVelocity(newVelocity, app);\n            const newPosition = (0, $056e076ec23198f1$export$ac4bca90992eed1).new(position.x + newRelativeVelocity.x, position.y + newRelativeVelocity.y);\n            entityManager.particles[i] = {\n                ...entityManager.particles[i],\n                velocity: newVelocity,\n                relativeVelocity: newRelativeVelocity,\n                position: newPosition\n            };\n        }\n    }\n    static _particleIntersectsObstacle(obstacle, position, options) {\n        const { data: [rectX, rectY, rectWidth, rectHeight] } = obstacle;\n        const rectHalfWidth = rectWidth / 2;\n        const rectHalfHeight = rectHeight / 2;\n        const rectCenterX = Math.abs(rectX + rectHalfWidth);\n        const rectCenterY = Math.abs(rectY + rectHalfHeight);\n        const circleDistance = (0, $056e076ec23198f1$export$ac4bca90992eed1).new(Math.abs(position.x - rectCenterX), Math.abs(position.y - rectCenterY));\n        if (circleDistance.x > rectHalfWidth + options.particleRadius) return false;\n        if (circleDistance.y > rectHalfHeight + options.particleRadius) return false;\n        if (circleDistance.x <= rectHalfWidth) return true;\n        if (circleDistance.y <= rectHalfHeight) return true;\n        const cornerDistanceSquared = (circleDistance.x - rectHalfWidth) * 2 + (circleDistance.y - rectHalfHeight) * 2;\n        return cornerDistanceSquared <= options.particleRadius * 2;\n    }\n    //FIXME: Separate collision detection from collision response to allow for event listeners\n    static _resolveObstacleCollisions(particleIndex, entityManager, options) {\n        for(let i = 0; i < entityManager.obstacles.length; i++){\n            // eslint-disable-next-line prefer-const\n            let { position: newPosition, velocity: newVelocity } = entityManager.particles[particleIndex];\n            if ($a92a30bff2b267c9$export$2f09efa5b67124a7._particleIntersectsObstacle(entityManager.obstacles[i], newPosition, options)) {\n                const { data: [rectX, rectY, rectWidth, rectHeight] } = entityManager.obstacles[i];\n                const obstacleLeftX = rectX;\n                const obstacleRightX = rectX + rectWidth;\n                const obstacleTopY = rectY;\n                const obstacleBottomY = rectY + rectHeight;\n                const collisionPoint = (0, $056e076ec23198f1$export$ac4bca90992eed1).new(newPosition.x < obstacleLeftX ? obstacleLeftX : newPosition.x > obstacleRightX ? obstacleRightX : newPosition.x, newPosition.y < obstacleTopY ? obstacleTopY : newPosition.y > obstacleBottomY ? obstacleBottomY : newPosition.y);\n                const distance = Math.sqrt(Math.pow(collisionPoint.x - newPosition.x, 2) + Math.pow(collisionPoint.y - newPosition.y, 2));\n                const intersectionDepth = options.particleRadius - distance;\n                if (intersectionDepth > 0) {\n                    //if particle intersects obstacle, move particle away\n                    const newDx = (newPosition.x - collisionPoint.x) / distance;\n                    const newDy = (newPosition.y - collisionPoint.y) / distance;\n                    newPosition = (0, $056e076ec23198f1$export$ac4bca90992eed1).new(newPosition.x + newDx * intersectionDepth, newPosition.y + newDy * intersectionDepth);\n                }\n                entityManager.particles[particleIndex] = {\n                    ...entityManager.particles[particleIndex],\n                    position: newPosition,\n                    velocity: $a92a30bff2b267c9$export$2f09efa5b67124a7.applyFriction((0, $056e076ec23198f1$export$ac4bca90992eed1).reflectFromPoint(collisionPoint, newPosition, newVelocity), options)\n                };\n            }\n        }\n    }\n    static _resolveParticleCollisions(particleIndex, entityManager, options) {\n        let { position: newPosition, // eslint-disable-next-line prefer-const\n        velocity: newVelocity } = entityManager.particles[particleIndex];\n        for(let i = 0; i < entityManager.particles.length; i++){\n            if (i <= particleIndex) continue;\n            let { position: cPosition, // eslint-disable-next-line prefer-const\n            velocity: cVelocity } = entityManager.particles[i];\n            //check collision\n            const distanceX = cPosition.x - newPosition.x;\n            const distanceY = cPosition.y - newPosition.y;\n            const centerDistance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);\n            if (centerDistance < options.particleRadius * 2) {\n                //check if particles intersect\n                const intersectionDepth = options.particleRadius + options.particleRadius - centerDistance;\n                //if they intersect, move them apart evenly\n                if (intersectionDepth > 0) {\n                    const newDx = distanceX / centerDistance;\n                    const newDy = distanceY / centerDistance;\n                    newPosition = (0, $056e076ec23198f1$export$ac4bca90992eed1).new(newPosition.x - newDx * intersectionDepth / 2, newPosition.y - newDy * intersectionDepth / 2);\n                    cPosition = (0, $056e076ec23198f1$export$ac4bca90992eed1).new(cPosition.x + newDx * intersectionDepth / 2, cPosition.y + newDy * intersectionDepth / 2);\n                }\n                const collisionPoint = (0, $056e076ec23198f1$export$ac4bca90992eed1).add((0, $056e076ec23198f1$export$ac4bca90992eed1).multiplyScalar(newPosition, options.precalc.radiusFactor), (0, $056e076ec23198f1$export$ac4bca90992eed1).multiplyScalar(cPosition, options.precalc.radiusFactor));\n                entityManager.particles[particleIndex] = {\n                    ...entityManager.particles[particleIndex],\n                    position: newPosition,\n                    velocity: $a92a30bff2b267c9$export$2f09efa5b67124a7.applyFriction((0, $056e076ec23198f1$export$ac4bca90992eed1).reflectFromPoint(collisionPoint, cPosition, newVelocity), options)\n                };\n                entityManager.particles[i] = {\n                    ...entityManager.particles[i],\n                    position: cPosition,\n                    velocity: $a92a30bff2b267c9$export$2f09efa5b67124a7.applyFriction((0, $056e076ec23198f1$export$ac4bca90992eed1).reflectFromPoint(collisionPoint, newPosition, cVelocity), options)\n                };\n            }\n        }\n    }\n    static _resolveCollisions(particleIndex, entityManager, options) {\n        $a92a30bff2b267c9$export$2f09efa5b67124a7._resolveObstacleCollisions(particleIndex, entityManager, options);\n        $a92a30bff2b267c9$export$2f09efa5b67124a7._resolveParticleCollisions(particleIndex, entityManager, options);\n    }\n    static applyFriction(v, options) {\n        return (0, $056e076ec23198f1$export$ac4bca90992eed1).multiplyScalar(v, options.friction);\n    }\n    static getRelativeVelocity(v, app) {\n        //FIXME: изменение дельта тайма меняет результат симуляции, надо решать с интерполяцией что-то\n        return {\n            x: v.x * app.deltaTime,\n            y: v.y * app.deltaTime\n        };\n    }\n}\n\n\nclass $6cc4987330b8dabd$export$88530751e3977073 {\n    static drawFrame(app, options, entityManager) {\n        app.context.clearRect(0, 0, app.canvas.width, app.canvas.height);\n        entityManager.particles.forEach(({ position: position, color: color })=>{\n            app.context.beginPath();\n            app.context.fillStyle = color;\n            app.context.arc(position.x, position.y, options.particleRadius, 0, options.precalc.circleAngle);\n            app.context.fill();\n        });\n        this._drawObstacles(app, entityManager.obstacles);\n    }\n    static _drawObstacles(app, obstacles) {\n        obstacles.forEach(({ data: data })=>{\n            app.context.fillRect(...data);\n        });\n    }\n}\n\n\nclass $fca17017ffbb45ca$export$86fbec116b87613f {\n    constructor(options, entityManager){\n        if ($fca17017ffbb45ca$export$86fbec116b87613f._instance) return $fca17017ffbb45ca$export$86fbec116b87613f._instance;\n        $fca17017ffbb45ca$export$86fbec116b87613f._instance = this;\n        this.canvas = document.getElementById(\"canvas\");\n        this.context = this.canvas.getContext(\"2d\");\n        this.dpr = window.devicePixelRatio || 1;\n        this.rawDeltaTime = performance.now();\n        this.lastFrameTime = this.rawDeltaTime;\n        this.isPaused = false;\n        this.options = options;\n        this.entityManager = entityManager;\n        this.update = this.update.bind(this);\n        this.onPause = this.onPause.bind(this);\n    }\n    init() {\n        this.canvas.width = document.body.clientWidth * this.dpr;\n        this.canvas.height = document.body.clientHeight * this.dpr;\n        if (this.options.debug) window.addEventListener(\"click\", ()=>{\n            this.rawDeltaTime = 1;\n            this.lastFrameTime = 1;\n            (0, $a92a30bff2b267c9$export$2f09efa5b67124a7).prepareFrame(this.entityManager, this.options, this);\n            (0, $6cc4987330b8dabd$export$88530751e3977073).drawFrame(this, this.options, this.entityManager);\n        });\n        else {\n            window.addEventListener(\"click\", this.onPause);\n            window.requestAnimationFrame(this.update);\n        }\n    }\n    update(frameTime) {\n        this.rawDeltaTime = (frameTime - this.lastFrameTime) / 200;\n        this.lastFrameTime = frameTime;\n        window.requestAnimationFrame(this.update);\n        if (this.isPaused) return;\n        (0, $a92a30bff2b267c9$export$2f09efa5b67124a7).prepareFrame(this.entityManager, this.options, this);\n        (0, $6cc4987330b8dabd$export$88530751e3977073).drawFrame(this, this.options, this.entityManager);\n    }\n    onPause() {\n        this.isPaused = !this.isPaused;\n    }\n    get deltaTime() {\n        return this.rawDeltaTime;\n    }\n}\n\n\nconst $205b16af4c42845f$var$COLORS = [\n    \"red\",\n    \"green\",\n    \"blue\",\n    \"orange\",\n    \"pink\"\n];\nconst $205b16af4c42845f$var$options = new (0, $bbaf2cf5fdf02c7e$export$c019608e5b5bb4cb)({\n    debug: false\n});\nconst $205b16af4c42845f$var$entityManager = new (0, $1a12250a5920d5f0$export$c7b7134fd828a5)();\nfor(let i = 0; i <= 9; i++){\n    const x = 45 * (i + 1);\n    const y = 60 * (i + 1);\n    $205b16af4c42845f$var$entityManager.addParticle(x, y, i, 0, $205b16af4c42845f$var$COLORS[Math.floor(Math.random() * 5)]);\n}\n$205b16af4c42845f$var$entityManager.addObstacle(0, 800, 510, 20);\n$205b16af4c42845f$var$entityManager.addObstacle(0, 0, 20, 800);\n$205b16af4c42845f$var$entityManager.addObstacle(490, 0, 20, 800);\n$205b16af4c42845f$var$entityManager.addObstacle(0, 0, 500, 20);\nconst $205b16af4c42845f$var$app = new (0, $fca17017ffbb45ca$export$86fbec116b87613f)($205b16af4c42845f$var$options, $205b16af4c42845f$var$entityManager);\n$205b16af4c42845f$var$app.init();\n\n})();\n//# sourceMappingURL=index.42e16fab.js.map\n","import { Options } from './utils/Options'\r\nimport { EntityManager } from './utils/EntityManager'\r\nimport { App } from './utils/App'\r\n\r\nconst COLORS = [ 'red', 'green', 'blue', 'orange', 'pink' ]\r\n\r\nconst options = new Options({ debug: false })\r\n\r\nconst entityManager = new EntityManager()\r\n\r\nfor (let i = 0; i <= 9; i++) {\r\n    const x = 45 * (i + 1 % 8)\r\n    const y = 60 * (i + 1)\r\n\r\n    entityManager.addParticle(x, y, i, 0, COLORS[Math.floor(Math.random() * 5)] )\r\n}\r\n\r\nentityManager.addObstacle( 0, 800, 510, 20)\r\nentityManager.addObstacle(0, 0, 20, 800)\r\nentityManager.addObstacle(490, 0, 20, 800)\r\nentityManager.addObstacle(0, 0, 500, 20)\r\n\r\nconst app = new App(options, entityManager)\r\napp.init()\r\n","export class Options {\r\n    particleRadius: number\r\n    gravity: number\r\n    precalc: {\r\n        radiusFactor: number,\r\n        circleAngle: number\r\n    }\r\n    timeSpeedCoefficient: number\r\n    targetFrameTime: number\r\n    friction: number\r\n    debug: boolean\r\n    private static _instance?: Options\r\n\r\n    //FIXME: добавить возможность настраивать вещи налету\r\n    constructor({ debug } : { debug?: boolean }) {\r\n        if (Options._instance) {\r\n            return Options._instance\r\n        }\r\n        Options._instance = this\r\n        this.particleRadius = 20\r\n        this.gravity = 9.8\r\n        this.precalc = {\r\n            radiusFactor: this.particleRadius / (this.particleRadius + this.particleRadius),\r\n            circleAngle: 2 * Math.PI\r\n        }\r\n        this.timeSpeedCoefficient = 30\r\n        this.targetFrameTime = 1000 / 60\r\n        this.friction = 0.90\r\n        this.debug = !!debug\r\n    }\r\n}\r\n","import { Obstacle, Particle } from '../types/common'\r\nimport { Vec2 } from './Vector2'\r\n\r\nexport class EntityManager {\r\n    readonly particles: Particle[]\r\n    readonly obstacles: Obstacle[]\r\n    private static _instance?: EntityManager\r\n\r\n    constructor() {\r\n        if (EntityManager._instance) {\r\n            return EntityManager._instance\r\n        }\r\n        EntityManager._instance = this\r\n        this.particles = []\r\n        this.obstacles = []\r\n    }\r\n\r\n    addParticle = (x: number, y: number, xv: number, yv: number, color: string) => {\r\n        this.particles.push({\r\n            position: Vec2.new(x, y),\r\n            velocity: Vec2.new(xv, yv),\r\n            relativeVelocity: Vec2.new(0, 0),\r\n            color\r\n        })\r\n    }\r\n\r\n    //TODO: add possibility to create diagonal obstacles\r\n    addObstacle = (x: number, y: number, w: number, h: number) => {\r\n        this.obstacles.push({\r\n            data: [ x, y, w, h ],\r\n        })\r\n    }\r\n}\r\n","import { Vector2 } from '../types/common'\r\n\r\nexport class Vec2 {\r\n\r\n    static new(x?: number, y?: number): Vector2 {\r\n        return {\r\n            x : x ?? 0,\r\n            y : y ?? 0\r\n        }\r\n    }\r\n\r\n    static multiplyScalar({ x, y }: Vector2, num: number): Vector2 {\r\n        return {\r\n            x: x * num,\r\n            y: y * num\r\n        }\r\n    }\r\n\r\n    static add(v1: Vector2, v2: Vector2): Vector2 {\r\n        return {\r\n            x: v1.x + v2.x,\r\n            y: v1.y + v2.y\r\n        }\r\n    }\r\n\r\n    static subtract(v1: Vector2, v2: Vector2): Vector2 {\r\n        return {\r\n            x: v1.x - v2.x,\r\n            y: v1.y - v2.y\r\n        }\r\n    }\r\n\r\n    static dot(v1: Vector2, v2: Vector2): number {\r\n        return v1.x * v2.x + v1.y * v2.y\r\n    }\r\n\r\n    static magnitude({ x, y }: Vector2): number {\r\n        return Math.sqrt(x * x + y * y)\r\n    }\r\n\r\n    static normalize({ x, y }: Vector2): Vector2 {\r\n        const magnitude = Vec2.magnitude({ x, y })\r\n\r\n        return {\r\n            x: x / magnitude,\r\n            y: y / magnitude\r\n        }\r\n    }\r\n\r\n    static collisionNormal(collisionPoint: Vector2, position: Vector2): Vector2 {\r\n        return Vec2.normalize(Vec2.subtract(collisionPoint, position))\r\n    }\r\n\r\n    static reflectFromPoint(collisionPoint: Vector2, position: Vector2, velocity: Vector2): Vector2 {\r\n        const normal = Vec2.collisionNormal(collisionPoint, position)\r\n\r\n        return Vec2.subtract(velocity, Vec2.multiplyScalar(normal, 2 * Vec2.dot(velocity, normal)))\r\n    }\r\n\r\n    static reflectFromNormal(vector: Vector2, normal: Vector2) {\r\n        // v' = v - 2 * (v ∙ n/n ∙ n) * n\r\n        return Vec2.subtract(\r\n            vector,\r\n            Vec2.multiplyScalar(\r\n                normal,\r\n                (2 * Vec2.dot(vector, normal) / Vec2.dot(normal, normal))\r\n            )\r\n        )\r\n    }\r\n\r\n}\r\n","import { Options } from './Options'\r\nimport { EntityManager } from './EntityManager'\r\nimport { Physics } from './Physics'\r\nimport { Renderer } from './Renderer'\r\n\r\nexport class App {\r\n    //FIXME: сделать сеттеры/геттеры\r\n    canvas: HTMLCanvasElement\r\n    context: CanvasRenderingContext2D\r\n    dpr: number\r\n    rawDeltaTime: number\r\n    lastFrameTime: number\r\n    isPaused: boolean\r\n    private static _instance?: App\r\n    readonly entityManager: EntityManager\r\n    readonly options: Options\r\n\r\n    constructor(options: Options, entityManager: EntityManager) {\r\n        if (App._instance) {\r\n            return App._instance\r\n        }\r\n        App._instance = this\r\n        this.canvas = document.getElementById('canvas') as HTMLCanvasElement\r\n        this.context = this.canvas.getContext('2d')\r\n        this.dpr = window.devicePixelRatio || 1\r\n        this.rawDeltaTime = performance.now()\r\n        this.lastFrameTime = this.rawDeltaTime\r\n        this.isPaused = false\r\n        this.options = options\r\n        this.entityManager = entityManager\r\n\r\n        this.update = this.update.bind(this)\r\n        this.onPause = this.onPause.bind(this)\r\n    }\r\n\r\n    init() {\r\n        this.canvas.width = document.body.clientWidth * this.dpr\r\n        this.canvas.height = document.body.clientHeight * this.dpr\r\n\r\n        if (this.options.debug) {\r\n            window.addEventListener('click', () => {\r\n                this.rawDeltaTime = 1\r\n                this.lastFrameTime = 1\r\n                Physics.prepareFrame(this.entityManager, this.options, this)\r\n                Renderer.drawFrame(this, this.options, this.entityManager)\r\n            })\r\n        } else {\r\n            window.addEventListener('click', this.onPause)\r\n            window.requestAnimationFrame(this.update)\r\n        }\r\n    }\r\n\r\n    update(frameTime: number) {\r\n        this.rawDeltaTime = (frameTime - this.lastFrameTime) / 200\r\n        this.lastFrameTime = frameTime\r\n\r\n        window.requestAnimationFrame(this.update)\r\n        if (this.isPaused) return\r\n\r\n        Physics.prepareFrame(this.entityManager, this.options, this)\r\n        Renderer.drawFrame(this, this.options, this.entityManager)\r\n    }\r\n\r\n    onPause(){\r\n        this.isPaused = !this.isPaused\r\n    }\r\n\r\n    get deltaTime() {\r\n        return this.rawDeltaTime\r\n    }\r\n\r\n}\r\n","import { Obstacle, Vector2 } from '../types/common'\r\nimport { Vec2 } from './Vector2'\r\nimport { Options } from './Options'\r\nimport { App } from './App'\r\nimport { EntityManager } from './EntityManager'\r\n\r\nexport class Physics {\r\n    static prepareFrame(entityManager: EntityManager, options: Options, app: App) {\r\n        for (let i = 0; i < entityManager.particles.length; i++) {\r\n\r\n            Physics._resolveCollisions(i, entityManager, options)\r\n\r\n            const { position, velocity } = entityManager.particles[i]\r\n\r\n            const newVelocity = Vec2.new(velocity.x, velocity.y + options.gravity)\r\n            const newRelativeVelocity = Physics.getRelativeVelocity(newVelocity, app)\r\n            const newPosition = Vec2.new(position.x + newRelativeVelocity.x, position.y + newRelativeVelocity.y)\r\n\r\n            entityManager.particles[i] = {\r\n                ...entityManager.particles[i],\r\n                velocity: newVelocity,\r\n                relativeVelocity: newRelativeVelocity,\r\n                position: newPosition,\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _particleIntersectsObstacle(obstacle: Obstacle, position: Vector2, options: Options) {\r\n        const { data: [ rectX, rectY, rectWidth, rectHeight ] } = obstacle\r\n\r\n        const rectHalfWidth = rectWidth / 2\r\n        const rectHalfHeight = rectHeight / 2\r\n\r\n        const rectCenterX = Math.abs(rectX + rectHalfWidth)\r\n        const rectCenterY = Math.abs(rectY + rectHalfHeight)\r\n        const circleDistance = Vec2.new(\r\n            Math.abs(position.x - rectCenterX),\r\n            Math.abs(position.y - rectCenterY)\r\n        )\r\n\r\n        if (circleDistance.x > rectHalfWidth + options.particleRadius) return false\r\n        if (circleDistance.y > rectHalfHeight + options.particleRadius) return false\r\n        if (circleDistance.x <= rectHalfWidth) return true\r\n        if (circleDistance.y <= rectHalfHeight) return true\r\n\r\n        const cornerDistanceSquared = (circleDistance.x - rectHalfWidth) * 2 + (circleDistance.y - rectHalfHeight) * 2\r\n\r\n        return cornerDistanceSquared <= options.particleRadius * 2\r\n    }\r\n\r\n    //FIXME: Separate collision detection from collision response to allow for event listeners\r\n    private static _resolveObstacleCollisions(\r\n        particleIndex: number,\r\n        entityManager: EntityManager,\r\n        options: Options\r\n    ) {\r\n        for (let i = 0; i < entityManager.obstacles.length; i++) {\r\n\r\n            // eslint-disable-next-line prefer-const\r\n            let { position: newPosition, velocity: newVelocity } = entityManager.particles[particleIndex]\r\n\r\n            if (Physics._particleIntersectsObstacle(entityManager.obstacles[i], newPosition, options)) {\r\n                const { data: [ rectX, rectY, rectWidth, rectHeight ] } = entityManager.obstacles[i]\r\n\r\n                const obstacleLeftX = rectX\r\n                const obstacleRightX = rectX + rectWidth\r\n                const obstacleTopY = rectY\r\n                const obstacleBottomY = rectY + rectHeight\r\n\r\n                const collisionPoint = Vec2.new(\r\n                    newPosition.x < obstacleLeftX\r\n                        ? obstacleLeftX : newPosition.x > obstacleRightX\r\n                            ? obstacleRightX : newPosition.x,\r\n                    newPosition.y < obstacleTopY\r\n                        ? obstacleTopY : newPosition.y > obstacleBottomY\r\n                            ? obstacleBottomY : newPosition.y\r\n                )\r\n\r\n                const distance = Math.sqrt(\r\n                    Math.pow(collisionPoint.x - newPosition.x, 2)\r\n                    + Math.pow(collisionPoint.y - newPosition.y, 2)\r\n                )\r\n\r\n                const intersectionDepth = options.particleRadius - distance\r\n\r\n                if (intersectionDepth > 0) {\r\n                    //if particle intersects obstacle, move particle away\r\n\r\n                    const newDx = (newPosition.x - collisionPoint.x) / distance\r\n                    const newDy = (newPosition.y - collisionPoint.y) / distance\r\n                    newPosition = Vec2.new(\r\n                        newPosition.x + newDx * intersectionDepth,\r\n                        newPosition.y + newDy * intersectionDepth,\r\n                    )\r\n                }\r\n\r\n                entityManager.particles[particleIndex] = {\r\n                    ...entityManager.particles[particleIndex],\r\n                    position: newPosition,\r\n                    velocity: Physics.applyFriction(\r\n                        Vec2.reflectFromPoint(collisionPoint, newPosition, newVelocity), options\r\n                    )\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _resolveParticleCollisions(\r\n        particleIndex: number,\r\n        entityManager: EntityManager,\r\n        options: Options\r\n    ) {\r\n        let {\r\n            position: newPosition,\r\n            // eslint-disable-next-line prefer-const\r\n            velocity: newVelocity\r\n        } = entityManager.particles[particleIndex]\r\n\r\n        for (let i = 0; i < entityManager.particles.length; i++) {\r\n            if (i <= particleIndex) continue\r\n\r\n            let {\r\n                position: cPosition,\r\n                // eslint-disable-next-line prefer-const\r\n                velocity: cVelocity,\r\n            } = entityManager.particles[i]\r\n\r\n            //check collision\r\n            const distanceX = cPosition.x - newPosition.x\r\n            const distanceY = cPosition.y - newPosition.y\r\n            const centerDistance = Math.sqrt(distanceX * distanceX + distanceY * distanceY)\r\n\r\n            if (centerDistance < options.particleRadius * 2) {\r\n                //check if particles intersect\r\n                const intersectionDepth = options.particleRadius + options.particleRadius - centerDistance\r\n\r\n                //if they intersect, move them apart evenly\r\n                if (intersectionDepth > 0) {\r\n                    const newDx = distanceX / centerDistance\r\n                    const newDy = distanceY / centerDistance\r\n\r\n                    newPosition = Vec2.new(\r\n                        newPosition.x - newDx * intersectionDepth / 2,\r\n                        newPosition.y - newDy * intersectionDepth / 2,\r\n                    )\r\n\r\n                    cPosition = Vec2.new(\r\n                        cPosition.x + newDx * intersectionDepth / 2,\r\n                        cPosition.y + newDy * intersectionDepth / 2,\r\n                    )\r\n                }\r\n\r\n                const collisionPoint = Vec2.add(\r\n                    Vec2.multiplyScalar(newPosition, options.precalc.radiusFactor),\r\n                    Vec2.multiplyScalar(cPosition, options.precalc.radiusFactor)\r\n                )\r\n\r\n                entityManager.particles[particleIndex] = {\r\n                    ...entityManager.particles[particleIndex],\r\n                    position: newPosition,\r\n                    velocity: Physics.applyFriction(\r\n                        Vec2.reflectFromPoint(collisionPoint, cPosition, newVelocity),\r\n                        options\r\n                    )\r\n                }\r\n\r\n                entityManager.particles[i] = {\r\n                    ...entityManager.particles[i],\r\n                    position: cPosition,\r\n                    velocity: Physics.applyFriction(\r\n                        Vec2.reflectFromPoint(collisionPoint, newPosition, cVelocity),\r\n                        options\r\n                    )\r\n                }\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _resolveCollisions(\r\n        particleIndex: number,\r\n        entityManager: EntityManager,\r\n        options: Options,\r\n    ) {\r\n        Physics._resolveObstacleCollisions(particleIndex, entityManager, options)\r\n        Physics._resolveParticleCollisions(particleIndex, entityManager, options)\r\n    }\r\n\r\n    static applyFriction(v: Vector2, options: Options): Vector2 {\r\n        return Vec2.multiplyScalar(v, options.friction)\r\n    }\r\n\r\n    static getRelativeVelocity(v: Vector2, app: App): Vector2 {\r\n        //FIXME: изменение дельта тайма меняет результат симуляции, надо решать с интерполяцией что-то\r\n        return {\r\n            x: v.x * app.deltaTime,\r\n            y: v.y * app.deltaTime\r\n        }\r\n    }\r\n}\r\n","import { App } from './App'\r\nimport { Options } from './Options'\r\nimport { EntityManager } from './EntityManager'\r\nimport { Obstacle } from '../types/common'\r\n\r\nexport class Renderer {\r\n    static drawFrame(app: App, options: Options, entityManager: EntityManager) {\r\n        app.context.clearRect(0, 0, app.canvas.width, app.canvas.height)\r\n        entityManager.particles.forEach(({ position, color }) => {\r\n            app.context.beginPath()\r\n            app.context.fillStyle = color\r\n            app.context.arc(position.x, position.y, options.particleRadius, 0, options.precalc.circleAngle)\r\n            app.context.fill()\r\n        })\r\n        this._drawObstacles(app, entityManager.obstacles)\r\n    }\r\n\r\n    private static _drawObstacles(app: App, obstacles: Obstacle[]) {\r\n        obstacles.forEach(({ data }) => {\r\n            app.context.fillRect(...data)\r\n        })\r\n    }\r\n}\r\n"],"names":["$bbaf2cf5fdf02c7e$export$c019608e5b5bb4cb","constructor","debug","_instance","particleRadius","gravity","precalc","radiusFactor","circleAngle","Math","PI","timeSpeedCoefficient","targetFrameTime","friction","$056e076ec23198f1$export$ac4bca90992eed1","new","x","y","multiplyScalar","num","add","v1","v2","subtract","dot","magnitude","sqrt","normalize","collisionNormal","collisionPoint","position","reflectFromPoint","velocity","normal","reflectFromNormal","vector","$1a12250a5920d5f0$export$c7b7134fd828a5","addParticle","xv","yv","color","particles","push","relativeVelocity","addObstacle","w","h","obstacles","data","$a92a30bff2b267c9$export$2f09efa5b67124a7","prepareFrame","entityManager","options","app","i","length","_resolveCollisions","newVelocity","newRelativeVelocity","getRelativeVelocity","newPosition","_particleIntersectsObstacle","obstacle","rectX","rectY","rectWidth","rectHeight","rectHalfWidth","rectHalfHeight","circleDistance","abs","cornerDistanceSquared","_resolveObstacleCollisions","particleIndex","obstacleRightX","obstacleBottomY","distance","pow","intersectionDepth","newDx","newDy","applyFriction","_resolveParticleCollisions","cPosition","cVelocity","distanceX","distanceY","centerDistance","v","deltaTime","$6cc4987330b8dabd$export$88530751e3977073","drawFrame","context","clearRect","canvas","width","height","forEach","beginPath","fillStyle","arc","fill","_drawObstacles","fillRect","$fca17017ffbb45ca$export$86fbec116b87613f","document","getElementById","getContext","dpr","window","devicePixelRatio","rawDeltaTime","performance","now","lastFrameTime","isPaused","update","bind","onPause","init","body","clientWidth","clientHeight","addEventListener","requestAnimationFrame","frameTime","$205b16af4c42845f$var$COLORS","$205b16af4c42845f$var$options","$205b16af4c42845f$var$entityManager","floor","random","$205b16af4c42845f$var$app"],"version":3,"file":"index.42e16fab.js.map"}