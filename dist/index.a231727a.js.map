{"mappings":"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","sources":["<anon>","src/main.ts","src/utils/Options.ts","src/utils/EntityManager.ts","src/utils/Vector2.ts","src/utils/App.ts","src/utils/Physics.ts","src/utils/Renderer.ts"],"sourcesContent":["class $3099865926cec06a$export$c019608e5b5bb4cb {\n    //FIXME: добавить возможность настраивать вещи налету\n    constructor({ debug: debug }){\n        if ($3099865926cec06a$export$c019608e5b5bb4cb._instance) return $3099865926cec06a$export$c019608e5b5bb4cb._instance;\n        $3099865926cec06a$export$c019608e5b5bb4cb._instance = this;\n        this.particleRadius = 20;\n        this.gravity = 9.8;\n        this.precalc = {\n            radiusFactor: this.particleRadius / (this.particleRadius + this.particleRadius),\n            circleAngle: 2 * Math.PI\n        };\n        this.timeSpeedCoefficient = 30;\n        this.targetFrameTime = 1000 / 60;\n        this.friction = 0.90;\n        this.debug = !!debug;\n    }\n}\n\n\nclass $0f6bd7f5a80a8d98$export$ac4bca90992eed1 {\n    static new(x, y) {\n        return {\n            x: x ?? 0,\n            y: y ?? 0\n        };\n    }\n    static multiplyScalar({ x: x, y: y }, num) {\n        return {\n            x: x * num,\n            y: y * num\n        };\n    }\n    static add(v1, v2) {\n        return {\n            x: v1.x + v2.x,\n            y: v1.y + v2.y\n        };\n    }\n    static subtract(v1, v2) {\n        return {\n            x: v1.x - v2.x,\n            y: v1.y - v2.y\n        };\n    }\n    static dot(v1, v2) {\n        return v1.x * v2.x + v1.y * v2.y;\n    }\n    static magnitude({ x: x, y: y }) {\n        return Math.sqrt(x * x + y * y);\n    }\n    static normalize({ x: x, y: y }) {\n        const magnitude = $0f6bd7f5a80a8d98$export$ac4bca90992eed1.magnitude({\n            x: x,\n            y: y\n        });\n        return {\n            x: x / magnitude,\n            y: y / magnitude\n        };\n    }\n    static collisionNormal(collisionPoint, position) {\n        return $0f6bd7f5a80a8d98$export$ac4bca90992eed1.normalize($0f6bd7f5a80a8d98$export$ac4bca90992eed1.subtract(collisionPoint, position));\n    }\n    static reflectFromPoint(collisionPoint, position, velocity) {\n        const normal = $0f6bd7f5a80a8d98$export$ac4bca90992eed1.collisionNormal(collisionPoint, position);\n        return $0f6bd7f5a80a8d98$export$ac4bca90992eed1.subtract(velocity, $0f6bd7f5a80a8d98$export$ac4bca90992eed1.multiplyScalar(normal, 2 * $0f6bd7f5a80a8d98$export$ac4bca90992eed1.dot(velocity, normal)));\n    }\n    static reflectFromNormal(vector, normal) {\n        // v' = v - 2 * (v ∙ n/n ∙ n) * n\n        return $0f6bd7f5a80a8d98$export$ac4bca90992eed1.subtract(vector, $0f6bd7f5a80a8d98$export$ac4bca90992eed1.multiplyScalar(normal, 2 * $0f6bd7f5a80a8d98$export$ac4bca90992eed1.dot(vector, normal) / $0f6bd7f5a80a8d98$export$ac4bca90992eed1.dot(normal, normal)));\n    }\n}\n\n\nclass $713e4dac7758b778$export$c7b7134fd828a5 {\n    constructor(){\n        this.addParticle = (x, y, xv, yv, color)=>{\n            this.particles.push({\n                position: (0, $0f6bd7f5a80a8d98$export$ac4bca90992eed1).new(x, y),\n                velocity: (0, $0f6bd7f5a80a8d98$export$ac4bca90992eed1).new(xv, yv),\n                relativeVelocity: (0, $0f6bd7f5a80a8d98$export$ac4bca90992eed1).new(0, 0),\n                color: color\n            });\n        };\n        //TODO: add possibility to create diagonal obstacles\n        this.addObstacle = (x, y, w, h)=>{\n            this.obstacles.push({\n                data: [\n                    x,\n                    y,\n                    w,\n                    h\n                ]\n            });\n        };\n        if ($713e4dac7758b778$export$c7b7134fd828a5._instance) return $713e4dac7758b778$export$c7b7134fd828a5._instance;\n        $713e4dac7758b778$export$c7b7134fd828a5._instance = this;\n        this.particles = [];\n        this.obstacles = [];\n    }\n}\n\n\n\nclass $dc2d49eb9a6d3720$export$2f09efa5b67124a7 {\n    static prepareFrame(entityManager, options, app) {\n        for(let i = 0; i < entityManager.particles.length; i++){\n            const { position: position, velocity: velocity, relativeVelocity: relativeVelocity } = this._resolveParticleCollisions(i, entityManager, options, app);\n            const newPosition = {\n                x: position.x + relativeVelocity.x,\n                y: position.y + relativeVelocity.y\n            };\n            const newVelocity = {\n                x: velocity.x,\n                y: velocity.y + options.gravity\n            };\n            const newRelativeVelocity = $dc2d49eb9a6d3720$export$2f09efa5b67124a7.getRelativeVelocity(newVelocity, app);\n            entityManager.particles[i] = {\n                ...entityManager.particles[i],\n                position: newPosition,\n                velocity: newVelocity,\n                relativeVelocity: newRelativeVelocity\n            };\n        }\n    }\n    static _resolveParticleCollisions(particleIndex, entityManager, options, app) {\n        const { position: position, velocity: velocity, relativeVelocity: relativeVelocity, color: color } = entityManager.particles[particleIndex];\n        let [newPosition, newVelocity, newRelativeVelocity] = [\n            position,\n            velocity,\n            relativeVelocity\n        ];\n        for(let i = 0; i < entityManager.obstacles.length; i++){\n            const { data: [rectX, rectY, rectWidth, rectHeight] } = entityManager.obstacles[i];\n            const intersects = ()=>{\n                const rectHalfWidth = rectWidth / 2;\n                const rectHalfHeight = rectHeight / 2;\n                const rectCenterX = Math.abs(rectX + rectHalfWidth);\n                const rectCenterY = Math.abs(rectY + rectHalfHeight);\n                const circleDistance = (0, $0f6bd7f5a80a8d98$export$ac4bca90992eed1).new(Math.abs(newPosition.x - rectCenterX), Math.abs(newPosition.y - rectCenterY));\n                if (circleDistance.x > rectHalfWidth + options.particleRadius) return false;\n                if (circleDistance.y > rectHalfHeight + options.particleRadius) return false;\n                if (circleDistance.x <= rectHalfWidth) return true;\n                if (circleDistance.y <= rectHalfHeight) return true;\n                const cornerDistanceSquared = (circleDistance.x - rectHalfWidth) * 2 + (circleDistance.y - rectHalfHeight) * 2;\n                return cornerDistanceSquared <= options.particleRadius * 2;\n            };\n            if (intersects()) {\n                const obstacleLeftX = rectX;\n                const obstacleRightX = rectX + rectWidth;\n                const obstacleTopY = rectY;\n                const obstacleBottomY = rectY + rectHeight;\n                const collisionPoint = (0, $0f6bd7f5a80a8d98$export$ac4bca90992eed1).new(newPosition.x < obstacleLeftX ? obstacleLeftX : newPosition.x > obstacleRightX ? obstacleRightX : newPosition.x, newPosition.y < obstacleTopY ? obstacleTopY : newPosition.y > obstacleBottomY ? obstacleBottomY : newPosition.y);\n                const distance = Math.sqrt(Math.pow(collisionPoint.x - newPosition.x, 2) + Math.pow(collisionPoint.y - newPosition.y, 2));\n                const intersectionDepth = options.particleRadius - distance;\n                if (intersectionDepth > 0) {\n                    //if particle intersects obstacle, move particle away\n                    const newDx = (newPosition.x - collisionPoint.x) / distance;\n                    const newDy = (newPosition.y - collisionPoint.y) / distance;\n                    newPosition = (0, $0f6bd7f5a80a8d98$export$ac4bca90992eed1).new(newPosition.x + newDx * intersectionDepth, newPosition.y + newDy * intersectionDepth);\n                }\n                const reflectedVector = $dc2d49eb9a6d3720$export$2f09efa5b67124a7.applyFriction((0, $0f6bd7f5a80a8d98$export$ac4bca90992eed1).reflectFromPoint(collisionPoint, newPosition, newVelocity), options);\n                newVelocity = reflectedVector;\n                newRelativeVelocity = $dc2d49eb9a6d3720$export$2f09efa5b67124a7.getRelativeVelocity(reflectedVector, app);\n            }\n        }\n        for(let i = 0; i < entityManager.particles.length; i++){\n            if (i <= particleIndex) continue;\n            const { position: cPosition, velocity: cVelocity } = entityManager.particles[i];\n            //check collision\n            const dx = cPosition.x - newPosition.x;\n            const dy = cPosition.y - newPosition.y;\n            //FIXME: они разъезжаются на маке, потому что коллижен считается два раза для первой сферы\n            //UPD: добавил разлепление партиклов, мб это фиксит\n            //TODO: проверить, сохранилось ли это с введением DELTA_TIME\n            const centerDistance = Math.sqrt(dx * dx + dy * dy);\n            if (centerDistance < options.particleRadius * 2) {\n                //if collided, find collision point\n                const collisionPoint = (0, $0f6bd7f5a80a8d98$export$ac4bca90992eed1).add((0, $0f6bd7f5a80a8d98$export$ac4bca90992eed1).multiplyScalar(newPosition, options.precalc.radiusFactor), (0, $0f6bd7f5a80a8d98$export$ac4bca90992eed1).multiplyScalar(cPosition, options.precalc.radiusFactor));\n                //reflected vector for current sphere\n                const reflectedVector1 = $dc2d49eb9a6d3720$export$2f09efa5b67124a7.applyFriction((0, $0f6bd7f5a80a8d98$export$ac4bca90992eed1).reflectFromPoint(collisionPoint, cPosition, velocity), options);\n                //reflected vector for another sphere\n                const reflectedVector2 = $dc2d49eb9a6d3720$export$2f09efa5b67124a7.applyFriction((0, $0f6bd7f5a80a8d98$export$ac4bca90992eed1).reflectFromPoint(collisionPoint, newPosition, cVelocity), options);\n                //check if particles intersect\n                const intersectionDepth = options.particleRadius + options.particleRadius - centerDistance;\n                if (intersectionDepth > 0) {\n                    //if they intersect, move them apart evenly\n                    const newDx = dx / centerDistance;\n                    const newDy = dy / centerDistance;\n                    newPosition = (0, $0f6bd7f5a80a8d98$export$ac4bca90992eed1).new(newPosition.x - newDx * intersectionDepth / 2, newPosition.y - newDy * intersectionDepth / 2);\n                    const newPosition2 = (0, $0f6bd7f5a80a8d98$export$ac4bca90992eed1).new(cPosition.x + newDx * intersectionDepth / 2, cPosition.y + newDy * intersectionDepth / 2);\n                    entityManager.particles[i] = {\n                        ...entityManager.particles[i],\n                        position: newPosition2\n                    };\n                }\n                newVelocity = reflectedVector1;\n                newRelativeVelocity = $dc2d49eb9a6d3720$export$2f09efa5b67124a7.getRelativeVelocity(reflectedVector1, app);\n                entityManager.particles[i] = {\n                    ...entityManager.particles[i],\n                    velocity: reflectedVector2,\n                    relativeVelocity: $dc2d49eb9a6d3720$export$2f09efa5b67124a7.getRelativeVelocity(reflectedVector2, app)\n                };\n            }\n        }\n        return {\n            position: newPosition,\n            velocity: newVelocity,\n            relativeVelocity: newRelativeVelocity,\n            color: color\n        };\n    }\n    static applyFriction(v, options) {\n        return (0, $0f6bd7f5a80a8d98$export$ac4bca90992eed1).multiplyScalar(v, options.friction);\n    }\n    //FIXME: надо будет убрать в отдельный класс когда будут другие утилиты для физики\n    static getRelativeVelocity(v, app) {\n        //FIXME: изменение дельта тайма меняет результат симуляции, надо решать с интерполяцией что-то\n        return {\n            x: v.x / app.deltaTime,\n            y: v.y / app.deltaTime\n        };\n    }\n}\n\n\nclass $f7ea042211b1de9a$export$88530751e3977073 {\n    static drawFrame(app, options, entityManager) {\n        app.context.clearRect(0, 0, app.canvas.width, app.canvas.height);\n        entityManager.particles.forEach(({ position: position, color: color })=>{\n            app.context.beginPath();\n            app.context.fillStyle = color;\n            app.context.arc(position.x, position.y, options.particleRadius, 0, options.precalc.circleAngle);\n            app.context.fill();\n        });\n        this._drawObstacles(app, entityManager.obstacles);\n    }\n    static _drawObstacles(app, obstacles) {\n        obstacles.forEach(({ data: data })=>{\n            app.context.fillRect(...data);\n        });\n    }\n}\n\n\nclass $14ff683d0d2d0b78$export$86fbec116b87613f {\n    constructor(options, entityManager){\n        if ($14ff683d0d2d0b78$export$86fbec116b87613f._instance) return $14ff683d0d2d0b78$export$86fbec116b87613f._instance;\n        $14ff683d0d2d0b78$export$86fbec116b87613f._instance = this;\n        this.canvas = document.getElementById(\"canvas\");\n        this.context = this.canvas.getContext(\"2d\");\n        this.dpr = window.devicePixelRatio || 1;\n        this.rawDeltaTime = performance.now();\n        this.lastFrameTime = this.rawDeltaTime;\n        this.isPaused = false;\n        this.options = options;\n        this.entityManager = entityManager;\n        this.update = this.update.bind(this);\n        this.onPause = this.onPause.bind(this);\n    }\n    init() {\n        this.canvas.width = document.body.clientWidth * this.dpr;\n        this.canvas.height = document.body.clientHeight * this.dpr;\n        if (this.options.debug) window.addEventListener(\"click\", ()=>{\n            this.rawDeltaTime = 1;\n            this.lastFrameTime = 1;\n            (0, $dc2d49eb9a6d3720$export$2f09efa5b67124a7).prepareFrame(this.entityManager, this.options, this);\n            (0, $f7ea042211b1de9a$export$88530751e3977073).drawFrame(this, this.options, this.entityManager);\n        });\n        else {\n            window.addEventListener(\"click\", this.onPause);\n            window.requestAnimationFrame(this.update);\n        }\n    }\n    update(frameTime) {\n        this.rawDeltaTime = (frameTime - this.lastFrameTime) / this.options.targetFrameTime;\n        this.lastFrameTime = frameTime;\n        window.requestAnimationFrame(this.update);\n        if (this.isPaused) return;\n        (0, $dc2d49eb9a6d3720$export$2f09efa5b67124a7).prepareFrame(this.entityManager, this.options, this);\n        (0, $f7ea042211b1de9a$export$88530751e3977073).drawFrame(this, this.options, this.entityManager);\n    }\n    onPause() {\n        this.isPaused = !this.isPaused;\n    }\n    get deltaTime() {\n        return this.rawDeltaTime * this.options.timeSpeedCoefficient;\n    }\n}\n\n\nconst $deded05a08b16674$var$COLORS = [\n    \"red\",\n    \"green\",\n    \"blue\",\n    \"orange\",\n    \"pink\"\n];\nconst $deded05a08b16674$var$options = new (0, $3099865926cec06a$export$c019608e5b5bb4cb)({\n    debug: false\n});\nconst $deded05a08b16674$var$entityManager = new (0, $713e4dac7758b778$export$c7b7134fd828a5)();\nfor(let i = 0; i <= 9; i++){\n    const x = 45 * (i + 1);\n    // const y = 60 + 60 * Math.ceil(i / 8)\n    const y = 60 * (i + 1);\n    $deded05a08b16674$var$entityManager.addParticle(x, y, i, 0, $deded05a08b16674$var$COLORS[Math.floor(Math.random() * 5)]);\n}\n// entityManager.addParticle(60, 60, 90, 0)\n// entityManager.addParticle(300, 60, -80, 0)\n// entityManager.addParticle(150, 60, 90, 0)\n// entityManager.addParticle(250, 60, -80, 0)\n$deded05a08b16674$var$entityManager.addObstacle(0, 800, 510, 20);\n$deded05a08b16674$var$entityManager.addObstacle(0, 0, 20, 800);\n$deded05a08b16674$var$entityManager.addObstacle(490, 0, 20, 800);\n$deded05a08b16674$var$entityManager.addObstacle(0, 0, 500, 20);\nconst $deded05a08b16674$var$app = new (0, $14ff683d0d2d0b78$export$86fbec116b87613f)($deded05a08b16674$var$options, $deded05a08b16674$var$entityManager);\n$deded05a08b16674$var$app.init();\n\n\n//# sourceMappingURL=index.a231727a.js.map\n","import { Options } from './utils/Options'\r\nimport { EntityManager } from './utils/EntityManager'\r\nimport { App } from './utils/App'\r\n\r\nconst COLORS = [ 'red', 'green', 'blue', 'orange', 'pink' ]\r\n\r\nconst options = new Options({ debug: false })\r\n\r\nconst entityManager = new EntityManager()\r\n\r\nfor (let i = 0; i <= 9; i++) {\r\n    const x = 45 * (i + 1 % 8)\r\n    // const y = 60 + 60 * Math.ceil(i / 8)\r\n    const y = 60 * (i + 1)\r\n\r\n    entityManager.addParticle(x, y, i, 0, COLORS[Math.floor(Math.random() * 5)] )\r\n}\r\n// entityManager.addParticle(60, 60, 90, 0)\r\n// entityManager.addParticle(300, 60, -80, 0)\r\n// entityManager.addParticle(150, 60, 90, 0)\r\n// entityManager.addParticle(250, 60, -80, 0)\r\n\r\nentityManager.addObstacle( 0, 800, 510, 20)\r\nentityManager.addObstacle(0, 0, 20, 800)\r\nentityManager.addObstacle(490, 0, 20, 800)\r\nentityManager.addObstacle(0, 0, 500, 20)\r\n\r\nconst app = new App(options, entityManager)\r\napp.init()\r\n","export class Options {\r\n    particleRadius: number\r\n    gravity: number\r\n    precalc: {\r\n        radiusFactor: number,\r\n        circleAngle: number\r\n    }\r\n    timeSpeedCoefficient: number\r\n    targetFrameTime: number\r\n    friction: number\r\n    debug: boolean\r\n    private static _instance?: Options\r\n\r\n    //FIXME: добавить возможность настраивать вещи налету\r\n    constructor({ debug } : { debug?: boolean }) {\r\n        if (Options._instance) {\r\n            return Options._instance\r\n        }\r\n        Options._instance = this\r\n        this.particleRadius = 20\r\n        this.gravity = 9.8\r\n        this.precalc = {\r\n            radiusFactor: this.particleRadius / (this.particleRadius + this.particleRadius),\r\n            circleAngle: 2 * Math.PI\r\n        }\r\n        this.timeSpeedCoefficient = 30\r\n        this.targetFrameTime = 1000 / 60\r\n        this.friction = 0.90\r\n        this.debug = !!debug\r\n    }\r\n}\r\n","import { Obstacle, Particle } from '../types/common'\r\nimport { Vec2 } from './Vector2'\r\n\r\nexport class EntityManager {\r\n    readonly particles: Particle[]\r\n    readonly obstacles: Obstacle[]\r\n    private static _instance?: EntityManager\r\n\r\n    constructor() {\r\n        if (EntityManager._instance) {\r\n            return EntityManager._instance\r\n        }\r\n        EntityManager._instance = this\r\n        this.particles = []\r\n        this.obstacles = []\r\n    }\r\n\r\n    addParticle = (x: number, y: number, xv: number, yv: number, color: string) => {\r\n        this.particles.push({\r\n            position: Vec2.new(x, y),\r\n            velocity: Vec2.new(xv, yv),\r\n            relativeVelocity: Vec2.new(0, 0),\r\n            color\r\n        })\r\n    }\r\n\r\n    //TODO: add possibility to create diagonal obstacles\r\n    addObstacle = (x: number, y: number, w: number, h: number) => {\r\n        this.obstacles.push({\r\n            data: [ x, y, w, h ],\r\n        })\r\n    }\r\n}\r\n","import { Vector2 } from '../types/common'\r\n\r\nexport class Vec2 {\r\n\r\n    static new(x?: number, y?: number): Vector2 {\r\n        return {\r\n            x : x ?? 0,\r\n            y : y ?? 0\r\n        }\r\n    }\r\n\r\n    static multiplyScalar({ x, y }: Vector2, num: number): Vector2 {\r\n        return {\r\n            x: x * num,\r\n            y: y * num\r\n        }\r\n    }\r\n\r\n    static add(v1: Vector2, v2: Vector2): Vector2 {\r\n        return {\r\n            x: v1.x + v2.x,\r\n            y: v1.y + v2.y\r\n        }\r\n    }\r\n\r\n    static subtract(v1: Vector2, v2: Vector2): Vector2 {\r\n        return {\r\n            x: v1.x - v2.x,\r\n            y: v1.y - v2.y\r\n        }\r\n    }\r\n\r\n    static dot(v1: Vector2, v2: Vector2): number {\r\n        return v1.x * v2.x + v1.y * v2.y\r\n    }\r\n\r\n    static magnitude({ x, y }: Vector2): number {\r\n        return Math.sqrt(x * x + y * y)\r\n    }\r\n\r\n    static normalize({ x, y }: Vector2): Vector2 {\r\n        const magnitude = Vec2.magnitude({ x, y })\r\n\r\n        return {\r\n            x: x / magnitude,\r\n            y: y / magnitude\r\n        }\r\n    }\r\n\r\n    static collisionNormal(collisionPoint: Vector2, position: Vector2): Vector2 {\r\n        return Vec2.normalize(Vec2.subtract(collisionPoint, position))\r\n    }\r\n\r\n    static reflectFromPoint(collisionPoint: Vector2, position: Vector2, velocity: Vector2): Vector2 {\r\n        const normal = Vec2.collisionNormal(collisionPoint, position)\r\n\r\n        return Vec2.subtract(velocity, Vec2.multiplyScalar(normal, 2 * Vec2.dot(velocity, normal)))\r\n    }\r\n\r\n    static reflectFromNormal(vector: Vector2, normal: Vector2) {\r\n        // v' = v - 2 * (v ∙ n/n ∙ n) * n\r\n        return Vec2.subtract(\r\n            vector,\r\n            Vec2.multiplyScalar(\r\n                normal,\r\n                (2 * Vec2.dot(vector, normal) / Vec2.dot(normal, normal))\r\n            )\r\n        )\r\n    }\r\n\r\n}\r\n","import { Options } from './Options'\r\nimport { EntityManager } from './EntityManager'\r\nimport { Physics } from './Physics'\r\nimport { Renderer } from './Renderer'\r\n\r\nexport class App {\r\n    //FIXME: сделать сеттеры/геттеры\r\n    canvas: HTMLCanvasElement\r\n    context: CanvasRenderingContext2D\r\n    dpr: number\r\n    rawDeltaTime: number\r\n    lastFrameTime: number\r\n    isPaused: boolean\r\n    private static _instance?: App\r\n    readonly entityManager: EntityManager\r\n    readonly options: Options\r\n\r\n    constructor(options: Options, entityManager: EntityManager) {\r\n        if (App._instance) {\r\n            return App._instance\r\n        }\r\n        App._instance = this\r\n        this.canvas = document.getElementById('canvas') as HTMLCanvasElement\r\n        this.context = this.canvas.getContext('2d')\r\n        this.dpr = window.devicePixelRatio || 1\r\n        this.rawDeltaTime = performance.now()\r\n        this.lastFrameTime = this.rawDeltaTime\r\n        this.isPaused = false\r\n        this.options = options\r\n        this.entityManager = entityManager\r\n\r\n        this.update = this.update.bind(this)\r\n        this.onPause = this.onPause.bind(this)\r\n    }\r\n\r\n    init() {\r\n        this.canvas.width = document.body.clientWidth * this.dpr\r\n        this.canvas.height = document.body.clientHeight * this.dpr\r\n\r\n        if (this.options.debug) {\r\n            window.addEventListener('click', () => {\r\n                this.rawDeltaTime = 1\r\n                this.lastFrameTime = 1\r\n                Physics.prepareFrame(this.entityManager, this.options, this)\r\n                Renderer.drawFrame(this, this.options, this.entityManager)\r\n            })\r\n        } else {\r\n            window.addEventListener('click', this.onPause)\r\n            window.requestAnimationFrame(this.update)\r\n        }\r\n    }\r\n\r\n    update(frameTime: number) {\r\n        this.rawDeltaTime = (frameTime - this.lastFrameTime) / this.options.targetFrameTime\r\n        this.lastFrameTime = frameTime\r\n\r\n        window.requestAnimationFrame(this.update)\r\n        if (this.isPaused) return\r\n\r\n        Physics.prepareFrame(this.entityManager, this.options, this)\r\n        Renderer.drawFrame(this, this.options, this.entityManager)\r\n    }\r\n\r\n    onPause(){\r\n        this.isPaused = !this.isPaused\r\n    }\r\n\r\n    get deltaTime() {\r\n        return this.rawDeltaTime * this.options.timeSpeedCoefficient\r\n    }\r\n\r\n}\r\n","import { Particle, Vector2 } from '../types/common'\r\nimport { Vec2 } from './Vector2'\r\nimport { Options } from './Options'\r\nimport { App } from './App'\r\nimport { EntityManager } from './EntityManager'\r\n\r\nexport class Physics {\r\n    static prepareFrame(entityManager: EntityManager, options: Options, app: App) {\r\n        for (let i = 0; i < entityManager.particles.length; i++) {\r\n\r\n            const {\r\n                position,\r\n                velocity,\r\n                relativeVelocity\r\n            } = this._resolveParticleCollisions(i, entityManager, options, app)\r\n\r\n            const newPosition = {\r\n                x: position.x + relativeVelocity.x,\r\n                y: position.y + relativeVelocity.y\r\n            }\r\n            const newVelocity = {\r\n                x: velocity.x,\r\n                y: velocity.y + options.gravity\r\n            }\r\n            const newRelativeVelocity = Physics.getRelativeVelocity(newVelocity, app)\r\n\r\n            entityManager.particles[i] = {\r\n                ...entityManager.particles[i],\r\n                position: newPosition,\r\n                velocity: newVelocity,\r\n                relativeVelocity: newRelativeVelocity\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _resolveParticleCollisions(\r\n        particleIndex: number,\r\n        entityManager: EntityManager,\r\n        options: Options,\r\n        app: App\r\n    ): Particle {\r\n        const { position, velocity, relativeVelocity, color } = entityManager.particles[particleIndex]\r\n\r\n        let [ newPosition, newVelocity, newRelativeVelocity ] = [ position, velocity, relativeVelocity ]\r\n\r\n        for (let i = 0; i < entityManager.obstacles.length; i++) {\r\n            const { data: [ rectX, rectY, rectWidth, rectHeight ] } = entityManager.obstacles[i]\r\n\r\n            const intersects = () => {\r\n                const rectHalfWidth = rectWidth / 2\r\n                const rectHalfHeight = rectHeight / 2\r\n\r\n                const rectCenterX = Math.abs(rectX + rectHalfWidth)\r\n                const rectCenterY = Math.abs(rectY + rectHalfHeight)\r\n                const circleDistance = Vec2.new(\r\n                    Math.abs(newPosition.x - rectCenterX),\r\n                    Math.abs(newPosition.y - rectCenterY)\r\n                )\r\n\r\n                if (circleDistance.x > rectHalfWidth + options.particleRadius) return false\r\n                if (circleDistance.y > rectHalfHeight + options.particleRadius) return false\r\n                if (circleDistance.x <= rectHalfWidth) return true\r\n                if (circleDistance.y <= rectHalfHeight) return true\r\n\r\n                const cornerDistanceSquared = (circleDistance.x - rectHalfWidth) * 2 + (circleDistance.y - rectHalfHeight) * 2\r\n\r\n                return cornerDistanceSquared <= options.particleRadius * 2\r\n            }\r\n\r\n            if (intersects()) {\r\n                const obstacleLeftX = rectX\r\n                const obstacleRightX = rectX + rectWidth\r\n                const obstacleTopY = rectY\r\n                const obstacleBottomY = rectY + rectHeight\r\n\r\n                const collisionPoint = Vec2.new(\r\n                    newPosition.x < obstacleLeftX\r\n                        ? obstacleLeftX : newPosition.x > obstacleRightX\r\n                            ? obstacleRightX : newPosition.x,\r\n                    newPosition.y < obstacleTopY\r\n                        ? obstacleTopY : newPosition.y > obstacleBottomY\r\n                            ? obstacleBottomY : newPosition.y\r\n                )\r\n\r\n                const distance = Math.sqrt(\r\n                    Math.pow(collisionPoint.x - newPosition.x, 2)\r\n                    + Math.pow(collisionPoint.y - newPosition.y, 2)\r\n                )\r\n\r\n                const intersectionDepth = options.particleRadius - distance\r\n\r\n                if (intersectionDepth > 0) {\r\n                    //if particle intersects obstacle, move particle away\r\n\r\n                    const newDx = (newPosition.x - collisionPoint.x) / distance\r\n                    const newDy = (newPosition.y - collisionPoint.y) / distance\r\n                    newPosition = Vec2.new(\r\n                        newPosition.x + newDx * intersectionDepth,\r\n                        newPosition.y + newDy * intersectionDepth,\r\n                    )\r\n                }\r\n\r\n\r\n                const reflectedVector = Physics.applyFriction(\r\n                    Vec2.reflectFromPoint(collisionPoint, newPosition, newVelocity), options\r\n                )\r\n\r\n                newVelocity = reflectedVector\r\n                newRelativeVelocity = Physics.getRelativeVelocity(reflectedVector, app)\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < entityManager.particles.length; i++) {\r\n            if (i <= particleIndex) continue\r\n\r\n            const {\r\n                position: cPosition,\r\n                velocity: cVelocity,\r\n                // relativeVelocity: cRelativeVelocity\r\n            } = entityManager.particles[i]\r\n\r\n            //check collision\r\n            const dx = cPosition.x - newPosition.x\r\n            const dy = cPosition.y - newPosition.y\r\n            //FIXME: они разъезжаются на маке, потому что коллижен считается два раза для первой сферы\r\n            //UPD: добавил разлепление партиклов, мб это фиксит\r\n            //TODO: проверить, сохранилось ли это с введением DELTA_TIME\r\n            const centerDistance = Math.sqrt(dx * dx + dy * dy)\r\n\r\n            if (centerDistance < options.particleRadius * 2) {\r\n                //if collided, find collision point\r\n                const collisionPoint = Vec2.add(\r\n                    Vec2.multiplyScalar(newPosition, options.precalc.radiusFactor),\r\n                    Vec2.multiplyScalar(cPosition, options.precalc.radiusFactor)\r\n                )\r\n\r\n                //reflected vector for current sphere\r\n                const reflectedVector1 = Physics.applyFriction(\r\n                    Vec2.reflectFromPoint(collisionPoint, cPosition, velocity),\r\n                    options\r\n                )\r\n                //reflected vector for another sphere\r\n                const reflectedVector2 = Physics.applyFriction(\r\n                    Vec2.reflectFromPoint(collisionPoint, newPosition, cVelocity),\r\n                    options\r\n                )\r\n\r\n                //check if particles intersect\r\n                const intersectionDepth = options.particleRadius + options.particleRadius - centerDistance\r\n\r\n                if (intersectionDepth > 0) {\r\n                    //if they intersect, move them apart evenly\r\n\r\n                    const newDx = dx / centerDistance\r\n                    const newDy = dy / centerDistance\r\n\r\n                    newPosition = Vec2.new(\r\n                        newPosition.x - newDx * intersectionDepth / 2,\r\n                        newPosition.y - newDy * intersectionDepth / 2,\r\n                    )\r\n\r\n                    const newPosition2 = Vec2.new(\r\n                        cPosition.x + newDx * intersectionDepth / 2,\r\n                        cPosition.y + newDy * intersectionDepth / 2,\r\n                    )\r\n\r\n                    entityManager.particles[i] = {\r\n                        ...entityManager.particles[i],\r\n                        position: newPosition2,\r\n                    }\r\n                }\r\n\r\n                newVelocity = reflectedVector1\r\n                newRelativeVelocity = Physics.getRelativeVelocity(reflectedVector1, app)\r\n\r\n                entityManager.particles[i] = {\r\n                    ...entityManager.particles[i],\r\n                    velocity: reflectedVector2,\r\n                    relativeVelocity: Physics.getRelativeVelocity(reflectedVector2, app)\r\n                }\r\n            }\r\n        }\r\n\r\n        return {\r\n            position: newPosition,\r\n            velocity: newVelocity,\r\n            relativeVelocity: newRelativeVelocity,\r\n            color\r\n        }\r\n    }\r\n\r\n    static applyFriction(v: Vector2, options: Options): Vector2 {\r\n        return Vec2.multiplyScalar(v, options.friction)\r\n    }\r\n\r\n    //FIXME: надо будет убрать в отдельный класс когда будут другие утилиты для физики\r\n    static getRelativeVelocity(v: Vector2, app: App): Vector2 {\r\n        //FIXME: изменение дельта тайма меняет результат симуляции, надо решать с интерполяцией что-то\r\n        return {\r\n            x: v.x / app.deltaTime,\r\n            y: v.y / app.deltaTime\r\n        }\r\n    }\r\n}\r\n","import { App } from './App'\r\nimport { Options } from './Options'\r\nimport { EntityManager } from './EntityManager'\r\nimport { Obstacle } from '../types/common'\r\n\r\nexport class Renderer {\r\n    static drawFrame(app: App, options: Options, entityManager: EntityManager) {\r\n        app.context.clearRect(0, 0, app.canvas.width, app.canvas.height)\r\n        entityManager.particles.forEach(({ position, color }) => {\r\n            app.context.beginPath()\r\n            app.context.fillStyle = color\r\n            app.context.arc(position.x, position.y, options.particleRadius, 0, options.precalc.circleAngle)\r\n            app.context.fill()\r\n        })\r\n        this._drawObstacles(app, entityManager.obstacles)\r\n    }\r\n\r\n    private static _drawObstacles(app: App, obstacles: Obstacle[]) {\r\n        obstacles.forEach(({ data }) => {\r\n            app.context.fillRect(...data)\r\n        })\r\n    }\r\n}\r\n"],"names":["$3099865926cec06a$export$c019608e5b5bb4cb","constructor","debug","_instance","particleRadius","gravity","precalc","radiusFactor","circleAngle","Math","PI","timeSpeedCoefficient","targetFrameTime","friction","$0f6bd7f5a80a8d98$export$ac4bca90992eed1","new","x","y","multiplyScalar","num","add","v1","v2","subtract","dot","magnitude","sqrt","normalize","collisionNormal","collisionPoint","position","reflectFromPoint","velocity","normal","reflectFromNormal","vector","$713e4dac7758b778$export$c7b7134fd828a5","addParticle","xv","yv","color","particles","push","relativeVelocity","addObstacle","w","h","obstacles","data","$dc2d49eb9a6d3720$export$2f09efa5b67124a7","prepareFrame","entityManager","options","app","i","length","_resolveParticleCollisions","newPosition","newVelocity","newRelativeVelocity","getRelativeVelocity","particleIndex","rectX","rectY","rectWidth","rectHeight","intersects","rectHalfWidth","rectHalfHeight","rectCenterX","abs","rectCenterY","circleDistance","cornerDistanceSquared","obstacleRightX","obstacleBottomY","distance","pow","intersectionDepth","newDx","newDy","reflectedVector","applyFriction","cPosition","cVelocity","dx","dy","centerDistance","reflectedVector1","reflectedVector2","newPosition2","v","deltaTime","$f7ea042211b1de9a$export$88530751e3977073","drawFrame","context","clearRect","canvas","width","height","forEach","beginPath","fillStyle","arc","fill","_drawObstacles","fillRect","$14ff683d0d2d0b78$export$86fbec116b87613f","document","getElementById","getContext","dpr","window","devicePixelRatio","rawDeltaTime","performance","now","lastFrameTime","isPaused","update","bind","onPause","init","body","clientWidth","clientHeight","addEventListener","requestAnimationFrame","frameTime","$deded05a08b16674$var$COLORS","$deded05a08b16674$var$options","$deded05a08b16674$var$entityManager","floor","random","$deded05a08b16674$var$app"],"version":3,"file":"index.a231727a.js.map"}